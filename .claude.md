# Claude Code Guidelines for ThumbsUp Combat Robot

This document provides specific guidelines for AI assistants working on the ThumbsUp firmware codebase.

## Critical Rules

### ⚠️ NEVER Use Blocking Sleeps

**DO NOT use `sleep_ms()` or `sleep_us()` in:**
- Main control loop
- Bluetooth processing code
- Any code that runs while the robot is operational
- Anywhere the controller connection needs to be serviced

**Why:** This is a bare-metal system (no RTOS). Blocking sleeps cause:
- Bluetooth controller packets to stop being processed
- Failsafe triggers (1500ms timeout)
- System crashes or watchdog resets
- Loss of control during operation

**Exception:** Only use blocking sleeps during:
- One-time initialization at boot
- Mode transitions where the robot is stationary
- **ONLY if you verify the robot won't be actively controlled**

### Use Non-Blocking Patterns Instead

**✅ CORRECT - Time-based state machine:**
```c
static uint32_t last_update = 0;
uint32_t now = to_ms_since_boot(get_absolute_time());

if (now - last_update > DELAY_TIME_MS) {
    // Do the thing
    last_update = now;
}
```

**❌ WRONG - Blocking sleep:**
```c
do_thing();
sleep_ms(1000);  // BLOCKS EVERYTHING!
do_next_thing();
```

**✅ CORRECT - LED feedback:**
```c
// Set LED state
status_set_led_color(0, COLOR_GREEN, LED_EFFECT_SOLID);
// LED updates automatically through status_update() in main loop
// No sleep needed!
```

**❌ WRONG - LED feedback with sleep:**
```c
status_set_led_color(0, COLOR_GREEN, LED_EFFECT_SOLID);
sleep_ms(500);  // CRASHES THE SYSTEM!
status_set_led_color(0, COLOR_OFF, LED_EFFECT_SOLID);
```

## LED Color Format

**IMPORTANT:** The SK6812 LEDs use **GRB byte order**, NOT RGB!

**Format:** `0x00GGRRBB` (Green-Red-Blue)

**Examples:**
```c
#define COLOR_GREEN  0x00FF0000  // Green: G=FF, R=00, B=00
#define COLOR_RED    0x0000FF00  // Red:   G=00, R=FF, B=00
#define COLOR_BLUE   0x000000FF  // Blue:  G=00, R=00, B=FF
#define COLOR_CYAN   0x00FF00FF  // Cyan:  G=FF, R=00, B=FF
```

Never assume RGB format without testing!

## System Architecture

### Main Loop (10ms cycle)
```
bluetooth_update()
  ├─ Process controller input
  ├─ trim_mode_check_activation()
  ├─ Drive control
  └─ Motor updates

status_update()  // Updates LEDs non-blocking
safety_check()
weapon_update()
```

### Timing Budget
- Main loop: 10ms (100Hz)
- LED update: ~120μs (negligible)
- **NEVER block for >1ms in the main loop**

## Bluetooth Controller

### Failsafe Timing
- Timeout: 1500ms without controller packets
- Triggers emergency stop
- **Any blocking code >1500ms will trigger failsafe!**

### Controller Update Rate
- Typical: 50-100Hz
- Must be processed continuously
- Missing packets triggers failsafe

## Hardware Pin Configuration

- GP0: Left drive motor PWM
- GP1: Right drive motor PWM
- GP2: Weapon motor PWM
- GP28: SK6812 addressable LEDs (2 LEDs, GRB format)
- GP8: Safety button (optional)
- GP26: Battery voltage monitor (ADC0)

## Safety-Critical Code

### Always Validate Inputs
```c
// SAFETY: Validate inputs to prevent overflow
if (input < MIN_VALUE || input > MAX_VALUE) {
    DEBUG_PRINT("Invalid input: %d\n", input);
    safe_fallback_action();
    return;
}
```

### Integer Math Only
- This is embedded firmware - use integer math
- Float math is acceptable but use sparingly
- Never use division by zero without checks

### Watchdog-Friendly
- Keep operations fast (<10ms)
- Break long operations into chunks
- Use state machines for multi-step processes

## Testing Considerations

### Before Committing Changes:
1. **Build test:** Ensure compilation succeeds
2. **Runtime test:** Flash to hardware if possible
3. **Blocking check:** Search for `sleep_ms` or `sleep_us` in changed files
4. **Timing analysis:** Will this code block the main loop?
5. **Safety verification:** Do safety systems still work?

### Common Issues to Watch For:
- Blocking sleeps (use grep to check!)
- RGB vs GRB color format mistakes
- Missing bounds checks on controller input
- Flash operations without interrupt disable
- Division by zero
- Integer overflow in calculations

## File Organization

### Critical Files:
- `src/bluetooth_platform.c` - Controller processing (NEVER block here!)
- `src/drive.c` - Motor mixing and control
- `src/status.c` - LED status system
- `src/trim_mode.c` - Trim calibration system
- `src/safety.c` - Safety monitoring

### Configuration:
- `include/config.h` - All system parameters and pin definitions
- Use #define for all magic numbers

## Common Patterns

### LED Feedback Pattern
```c
// Set the desired state
status_set_led_color(led_index, color, effect);

// LED will update automatically through status_update()
// No additional code needed!
```

### Timer-Based Actions
```c
static uint32_t action_start_time = 0;
static bool action_active = false;

if (trigger_condition && !action_active) {
    action_active = true;
    action_start_time = to_ms_since_boot(get_absolute_time());
}

if (action_active) {
    uint32_t now = to_ms_since_boot(get_absolute_time());
    if (now - action_start_time > DURATION_MS) {
        // Action complete
        action_active = false;
    }
}
```

### Flash Operations
```c
// ALWAYS disable interrupts during flash operations
uint32_t ints = save_and_disable_interrupts();

flash_range_erase(offset, size);
flash_range_program(offset, data, size);

restore_interrupts(ints);
```

## Summary

1. **NEVER use blocking sleeps** in operational code
2. **Use GRB color format** for LEDs
3. **Keep main loop fast** (<10ms per iteration)
4. **Validate all inputs** for safety
5. **Test on hardware** when possible
6. **Use non-blocking patterns** for everything

When in doubt, use a time-based state machine instead of blocking operations.
